
# 자리수에 따라서, 0과 1이 맨 뒷자리로 올 수 있는 경우의 수를 1차원 배열에 넣습니다.
# 자리수마다 나온 배열들을 합쳐 2차원 리스트로 만들고 그 리스트 안에서 규칙을 찾아 점화식을 세우는 방법을 사용하였습니다.

# dp[N][0] = dp[N-1][0]+dp[N-1][1]
# dp[N][1] = dp[N-1][0]
# dp[N] = dp[N][0]+dp[N][1]

# 첫째 줄에 N이 주어진다. N은 0이상 90이하
N = int(input())

# dp 만들기
# 이중 리스트로
dp = [[0]*2 for _ in range(N+1)]

# dp 값 넣어보기
# 해설은 그림 참고
dp[1][0]=0
dp[1][1]=1

for i in range(2, N+1):
    for j in range(2):
        dp[i][0] = dp[i-1][0]+dp[i-1][1]
        dp[i][1] = dp[i-1][0]

# 첫째 줄에 N자리 이친수의 개수를 출력한다.
print(sum(dp[N]))