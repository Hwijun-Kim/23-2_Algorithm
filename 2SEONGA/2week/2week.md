# dp를 딕셔너리로 초기화
# dp가 1일 때, 0 값을 갖는 것의 의미는 1일 때 1이 되는데 필요한 연산 횟수가 0회라는 것
# rec함수는 숫자 n을 입력받아, 재귀적으로 dp 딕셔너리를 채움
# rec함수의 종료 조건은 입력받은 n이 dp딕셔너리의 key에 존재하는 경우 dp[n]을 리턴

if (n%3==0) and (n%2==0): 
        dp[n]=min(rec(n//3)+1, rec(n//2)+1)

-> n이 3으로도 나누어 떨어지고, 2로도 나누어 떨어지는 경우, rec(n//3)+1, rec(n//2)+1중 최솟값을 dp[n]에 넣습니다. rec(n//3)+1이 의미하는 것은 n을 3으로 나눈 몫이 1이 되는데 필요한 최소 연산 횟수 + n을 3으로 나누는 연산횟수 1회입니다. 즉, 3으로 나눈 경우와 2로 나눈 경우중 연산 횟수가 더 적은 쪽이 dp[n]에 들어갑니다.
    elif n%3==0:
        dp[n]=min(rec(n//3)+1, rec(n-1)+1)

-> n이 3으로만 나누어 떨어지는 경우는 3으로 나눈 경우(rec(n//3)+1)와 n에서 1을 뺀 뒤, n-1이 1이 되는데 걸리는 최소 연산 횟수인 rec(n-1)+1을 비교하여 최솟값을 dp[n]에 넣습니다.
    elif n%2==0:
        dp[n]=min(rec(n//2)+1, rec(n-1)+1)

-> n이 2로만 나누어 떨어지는 경우도 마찬가지로 n을 2로 나눈 경우와 n에서 1을 뺀 경우를 비교하여 최솟값을 dp[n]에 넣습니다.
    else:
        dp[n]=rec(n-1)+1

-> n이 3으로도 나누어 떨어지지 않고, 2로도 나누어 떨어지지 않는 경우는 n에서 1을 뺀 값인 n-1이 1이 되는데 걸리는 최소한의 연산 횟수 + 1회(n에서 1을 빼는 연산 1회)를 dp[n]에 넣어줍니다.

    return dp[n]

-> 마지막 return dp[n]은 재귀 호출을 모두 마무리하고, rec(x)의 결과를 최종 반환할 때 쓰입니다.